基于 RK3588 自研核心板上进行 Linux 应用开发，完成交叉编译工具链配置与调试，熟练使用 GCC、 Makefile 构建系统涉及系统调用、文件 IO、串口通信、Socket 网络通信；
 
构建 RK3588 与 FPGA 间的 PCIe 通信链路，手写 Linux 字符设备驱动及 ioctl 命令，实现 2.5GB/s 零拷贝高速图像与控制数据交互；

完成 U-Boot 启动引导程序移植、Linux 内核裁剪与根文件系统构建，实现从底层到系统的启动流程定制；

使用 PyTorch 导出的 YOLOv8 模型，通过自定义手写算子， 实现 ONNX 转换部署至 RK3588 平台，调用 NPU 量化模型加速推理，实现轻量级无人机目标检测与目标跟踪任务；
 
基于 Qt 构建部署端的图形化界面，实现模型推理结果展示、参数调试、图像回显与系统控制等功能；
 
搭建基于 AM6442 的 TSN 协议的网口通信环境，实现毫秒级时延保障的数据传输链路；

 
<img width="1832" height="1119" alt="image" src="https://github.com/user-attachments/assets/5a5c5ea6-909f-43c1-95ac-01bcf0f94c63" />


## 项目梳理

Xilinx Zynq-7020 SoC FPGA  Linux 5.15.5    U-Boot 2022.04

PECI是一种高速**串行**通信协议，是一种**异步**通信机制，**点对点**，**全双工**的通信链路，**不共享带宽**。  在PCIe系统里，是点对点传输的：

* 一条PCIe总线只能接一个PCIe设备
  
* 要接多个PCIe设备，必须使用Switch进行扩展

PCIE层次结构和数据包： 

事务层 传输的是Transaction Layer Packet(TLP)

数据链路层   传输的是Data Link Layer Packet(DLLP)

物理层 传输的是Physical Packet

BAR 是用来存储设备的内存映射地址的寄存器  每个设备通过 BAR 来告知操作系统其 I/O 地址或内存地址空间，操作系统通过这些地址与设备进行数据交换。

PCIE设备初始化时会通过BAR暴露出自身的内存映射空间，主机驱动可以通过读取BAR获取物理地址并映射访问，传送用DMA

DMA：是一种不经过CPU，直接在设备和内存之间传输数据的机制。 需要设置 源地址、目标地址、数据长度、接受缓冲区（网络有环形缓冲区ring buffer）

DMA传输流程：使能时钟、配置DMA参数（源、目标、长度、触发方式（中断、轮询））、发起DMA传输请求、DMA控制器数据搬运、传输完成（中断通知CPU）

FPGA采集图像数据通过PCIE DMA直接传输到RK3588的DDR中，由驱动映射和中断管理，极大提高了传输速率。

传输方式：

1、首先建立PCIE通信链路，RK3588作为RC，FPGA的IP核配置为EP，ARM这边lspci查看FPGA设备

2、RK3588设备树修改，DTS 中打开 PCIe RC，再PCIE 3X4中匹配FPGA的Lane数  使用 lscpi -vvv 查看PCIE设备列表及链路状态  dmesg | grep pci 查看内存初始化日志  `dmesg` 查看内核日志，确认 PCIe 驱动是否加载成功，是否有中断注册等异常信息。

3、RK3588Linux驱动配置... pcie驱动框架   加载 `xilinx-pcie-dma`驱动

4、FPGA实现Endponit，FPGA的TLP地址  == RK3588的DDR物理地址    

5、配置DMA，传输期间不需要CPU介入   通过ioctl函数启动DMA（写/读） 都是用ioctl来启动DMA的  可以使用PingPang缓存 （管道）来存储发送的数据
 
6、缓存一致性：DMA 是**直接操作物理内存**的，但 CPU 一般是**通过缓存（Cache）访问内存**的。 因此：**DMA 和 CPU 可能看到的数据不一致**  **DMA 和 CPU 是并行访问内存的，为了防止数据不一致，我们在 DMA 传输前后需要维护缓存一致性。这就需要刷新缓存区。**


**在我的项目中，DMA 是由RK3588发起的。FPGA 采集图像后，构造 PCIe TLP，DMA将数据写入 RK3588 的 DDR 缓冲区。整个传输过程实现了零拷贝、低延迟，适合高速图像数据的实时处理。**

PCIe Gen2 x1 理论带宽 ≈ 500MB/s   4x 	2G/s

图像数据：MIPI摄像头接口， OV5640摄像头模块  数据格式支持 YUV  分辨率为640*480  输出最大为 500万像素的图像 (2592x1944分辨率) 15-60帧可调  

## Linux PCIE驱动步骤

1、确保内核的PCIE支持，内核已经启动了**PCIE子系统**的支持

2、修改内核配置以支持PCIE， 进入内核配置菜单manuconfig   启动PCIE支持，在Device Drivers --> PCI Port Bus Support    启动PCI EXpress Hotplug Support 需要支持热插拔  

3、 编译内核 

4、修改设备树DTS  在设备树中配置PCIE根复杂设备（Root Complex） 配置PCIE设备节点 编译设备树  修改bootargs 启动的方式

5、 编写和配置PCIE驱动 PCIE驱动框架： 设备初始化（probe） 资源管理  数据传输   设备移除（remove）

驱动示例： 内核模块的 init 和 exit 函数   设备匹配和初始化（probe）  设备操作接口：file_operations  中断处理   驱动程序注册  解除内存映射  pci_iounmap(pdev, bar0)
   
