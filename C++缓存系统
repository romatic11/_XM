# C++项目缓存系统

**缓存污染**：指访问很少的数据在服务器访问请求后还继续在缓存中，造成缓存空间浪费。

缓存污染一旦变严重后，有大量不再访问的数据滞留在缓存中，往缓存中写入新数据时需要先把数据淘汰出缓存，引入额外的时间开销。

再加一个**数据持久化** 防止进程崩溃

![image-20250801150042427](D:/Typora%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/image-20250801150042427.png)

[缓存系统（C++）](https://www.yuque.com/chengxuyuancarl/ctp2tl?#)	dozg

**LRU：最近最久未使用页面置换算法**（淘汰 **最久未被访问** 的数据）    **双向链表 + 哈希表**。每次访问将数据移到链表头部，淘汰时从尾部移除。

**LFU：最不经常使用页面置换算法**（淘汰 **使用频率最低** 的数据）使用 **最小堆** 或 **哈希表 + 双链表** 实现 （如果某些旧数据曾经频繁使用但现在不再使用，它的频率仍然高，可能导致 **缓存污染**）

**ARC：自适应替换缓存算法**  **自适应结合 LRU 和 LFU**，无需人工选择。 ARC 维护四个队列：

- **T1**：最近访问一次的缓存（LRU）
- **T2**：最近访问多次的缓存（LFU）
- **B1**：曾在 T1 中但已被淘汰（Ghost for T1）
- **B2**：曾在 T2 中但已被淘汰（Ghost for T2）

根据命中 B1 还是 B2 来动态调整 T1/T2 的大小。

| 特性       | LRU                    | LFU                    | ARC                              |
| ---------- | ---------------------- | ---------------------- | -------------------------------- |
| 淘汰策略   | 最久未使用             | 使用最少               | 自适应 LRU 与 LFU                |
| 实现复杂度 | 低                     | 中                     | 高                               |
| 缓存局部性 | 时间局部性             | 频率局部性             | 兼顾时间+频率局部性              |
| 缺点       | 高频访问老数据可能淘汰 | 热但不再使用数据难淘汰 | 实现复杂，内存消耗略高           |
| 使用场景   | 普通缓存系统           | 热点数据明显、重复率高 | 多变访问模式、缓存失效率敏感系统 |

### FIFO

**Belady异常**当使用 **先进先出（FIFO）页面置换算法** 时，若未给进程分配其所需的全部页面，增加分配的页面数反而会导致 **缺页率提高** 的异常现象。

**缺页**：**当程序试图访问一个虚拟地址对应的页面时，发现该页面当前不在物理内存中**，而需要从外部存储（如磁盘上的交换区或文件）调入内存，这个过程就叫**缺页**。

- **缺页次数越少**，说明内存利用率高，程序运行流畅。

- **缺页次数越多**，可能意味着内存不足、算法效率低，或程序访问模式不合理。

**“缺页”就是每次访问一个页面时，发现它不在当前内存块里**，必须从外面“搬进来”，每搬一次就记一次“缺页”。



**LRU潜在问题**：淘汰热点数据，如果有个数据在1个小时的前59分钟访问了1万次(可见这是个热点数据),再后一分钟没有访问这个数据，但是有其他的数据访问，就导致了我们这个热点数据被淘汰。

### 智能指针

解决内存泄漏问题

**动态分配对象的所有权**

- **shared_ptr**：共享所有权，**“最后一个走的人关灯”**。
- **weak_ptr**：只旁观不拥有，**“临时借钥匙，用完归还”**。
- **unique_ptr**：**独占所有权**   不可拷贝，可移动，零开销

`std::shared_ptr`：共享所有权

- **引用计数**：每拷贝一次 `shared_ptr`，计数 +1；析构一次，计数 -1。
- **当计数变为 0**，对象自动被 `delete`。

 `std::weak_ptr`：非拥有式“观察者”

- **不增加引用计数**，因此不会影响对象生命周期。
- **使用前需先 `lock()` 成 `shared_ptr`**，确保对象仍存活。

`std::unique_ptr` **“一个对象，只能有一个主人；主人销毁，对象跟着销毁。”**

​	禁止拷贝，只能 **move** 转移所有权

​	离开作用域自动调用 `delete` 或自定义 deleter

- **unique_ptr**：一把钥匙，谁拿谁负责关门。
- **shared_ptr**：多人拿钥匙，最后出门的人关灯锁门。
- **weak_ptr**：站在门外看热闹，不拿钥匙也不锁门。

### 友元函数

它**不是类的成员函数**，却能够像成员一样**直接访问该类的所有成员**（包括 `private` / `protected`）

**打破封装，授予外部函数特权**

 **声明位置无限制，作用域在外部**

- 它**不属于类的成员**，因此：
  - **没有 `this` 指针**。
  - **不能用 `const` / `virtual` / `override` 等成员限定符**。

**不可继承、不可传递**

###  lock_guard<mutex> lock(mutex_)

是 **C++ 中最常见、最推荐的互斥量加锁方式**，它利用了 **RAII（资源获取即初始化）** 思想，确保：

> **只要 `lock` 对象存在，互斥量就被锁住；离开作用域时自动解锁，绝不遗漏。**

`std::lock_guard` 就是“**作用域锁**”：构造加锁，析构解锁，**锁随生命周期，异常也安全**。

- **get**：读缓存——**查到就返回 value，并把节点移到“最近使用”位置；查不到返回 false / 默认值**。
- **put**：写缓存——**键存在则更新 value 并置为最近使用；键不存在则插入新节点，超容时淘汰最久未用节点**。



### random_device ` + ` mt19937 

- `std::random_device`：产生一个真正的随机种子（硬件或系统级）
- `std::mt19937`：快速高质量的伪随机数生成器（梅森旋转算法）
- `gen() % N`：生成 `[0, N)` 范围的整数，用于决定操作行为、访问的 key 等

这保证了每次运行测试都能覆盖各种可能性，且行为具有一定的随机性但可控。

### 异步网络编程

**程序通过回调函数处理网络事件，而不是阻塞等待**。

| 模式                      | 描述                               | 举例                        |
| ------------------------- | ---------------------------------- | --------------------------- |
| **同步**（阻塞）          | 一行读写代码，直到完成才返回       | `recv()`, `send()` 等       |
| **异步**（非阻塞 + 回调） | 调用后立即返回，完成后通过回调通知 | `boost::asio::async_read()` |

`boost_system` 库

###  Boost.Asio 实现的异步机制：

- IO 操作不是立即执行，而是注册到事件循环（event loop）
- 当数据准备好，才触发对应的回调函数
- 避免线程阻塞，可以大幅提升性能（尤其是高并发服务器）

### 简单文本协议

每条命令一行，结尾 \n
命令支持：
  SET <key> <value>         → +OK\n
  GET <key>                 → $<len>\n<value>\n  (未命中为 $-1\n)
  DEL <key>                 → -ERR not-supported\n

### Boost是什么？

是C++高质量、开源的通用库集合。

|           模块           |            功能             |
| :----------------------: | :-------------------------: |
|        Boost.Asio        |     异步网络和串口通信      |
|     Boost.Filesystem     |       文件和路径操作        |
|       Boost.Thread       |         多线程编程          |
|       Boost.Regex        |       正则表达式处理        |
|      Boost.SmartPtr      | 智能指针（如 `shared_ptr`） |
| Boost.Optional / Variant |     可选类型 / 多态变量     |

✅ 重点内容

- 使用 `boost::asio::async_accept / async_read_until / async_write` 实现 **非阻塞 IO**
- 每个连接由 `Session` 类负责处理，避免主线程阻塞
- 读写操作通过 **回调函数** 在事件触发后处理

🎯 意义

- 支持成千上万个并发连接
- 避免 `std::thread` per connection 造成的资源浪费

### 高性能异步缓存服务器

基于 **Boost.Asio** 编写，支持简单的 KV 缓存指令，如 `GET`, `SET`, `DEL`, `STATS`。并可选择三种缓存算法：LRU、LFU、ARC。

- 支持 SET/GET/STATS 三条简单命令；
- 后端缓存算法可在 LRU/LFU/ARC 之间切换；
- 每个连接对应一个 Session，用异步读写避免阻塞；
- 主线程+工作线程池共同跑 io_context，实现高并发。

运行方式：

```
终端A
g++ CacheServerSkeleton.cpp -std=c++17 -pthread -lboost_system -o cache_server
# 参数顺序：<端口> <容量> <算法>
./cache_server <port> <capacity> <algo>
# 例如：
./cache_server 6379 10000 lru
```

```
终端B
nc 127.0.0.1 6379
SET 42 hello     返回：+OK
GET 42			返回：$5	hello
STATS
```



### **线程池并发模型（io_context.run 多线程）**

✅ 重点内容

```
cpp复制编辑unsigned n = std::thread::hardware_concurrency();
for (unsigned i = 0; i < n; ++i)
    workers.emplace_back([&]{ io.run(); });
```

🎯 意义

- 充分利用多核 CPU 的并发能力
- 将所有连接/事件交由 `io_context` 统一调度处理，保证线程安全



### 缓存穿透、缓存击穿和缓存雪崩



**缓存穿透**：请求的数据 **缓存和数据库中都不存在**，每次请求都会绕过缓存直接打到数据库，造成 **DB 负载过高**。

**后果**： 缓存**形同虚设**，数据库被恶意请求或异常数据打爆

解决办法：使用**布隆过滤器**过滤无效查询。提前判断 key 是否可能存在（典型方法）



**缓存击穿**：**某个热点数据刚好失效**，这时大量并发请求一起打到数据库，造成瞬时流量暴增。

比如热点视频、热搜词条的缓存过期了，1万用户同时刷新，都会穿透缓存打数据库。

**后果**：数据库瞬间被打爆、恢复缓存前系统性能急剧下降

解决方案：

1. **互斥锁（加锁/互斥）**：
   - 第一个线程去数据库，其余等待（如分布式锁/本地锁）
2. **提前预热 + 永不过期 + 后台更新**：
   - 不让热点数据失效，通过定时任务或延迟更新机制
3. **异步重建缓存**：
   - 缓存失效时快速返回旧值，异步线程后台更新



**缓存雪崩**：**大量缓存同时过期或不可用**，大量请求直接访问数据库，导致数据库或服务整体崩溃。

如系统重启后缓存全失效，或使用统一的过期时间（如设置都为10分钟）

**后果：**系统整体不可用、数据库 QPS 激增，雪崩效应传播

解决方案：

1. **设置随机过期时间（抖动）**：
   - 避免集中失效，如 `过期时间 = base + rand(0, 60s)`
2. **分批加载缓存**：
   - 热点数据预热、分批次逐步恢复
3. **多级缓存**：
   - 本地缓存 + 分布式缓存，降低一级缓存雪崩影响
4. **熔断降级**：
   - 缓存不可用时快速返回默认值，保护 DB
